<!DOCTYPE html>
<html>
<head>
    <script src="./phaser.js" type="text/javascript"></script>
    <style type="text/css">
    canvas{width:640px;height:480px;}
    </style>
</head>
<body>
    <script type="text/javascript">
        var speed = 0,
            maxSpeed = 150,   //maxSpeed = segmentLength/step,
            accel =  maxSpeed/5,
            breaking = -maxSpeed,
            decel = -maxSpeed/5;

        var Camera = function() {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.resolutionX = 1024;
            this.resolutionY = 768;
            this.fieldOfView = 100 * Math.PI / 180;
            this.depth = 1 / Math/tan(this.fieldOfView / 2);
        };

        Camera.prototype = {
            project : function(x, y, z) {
                var scale = this.depth / (z - this.cameraZ);
                return {
                    screenX : Math.round(this.resolutionX / 2 + this.resolutionX / 2 * scale * (x - this.cameraX)),
                    screenY : Math.round(this.resolutionY / 2 - this.resolutionY / 2 * scale * (y - this.cameraY))
                }
            }
        };

        var Road = function() {
            // 道路宽度（3d world）
            this.width = 2000;
            // 道路分段
            this.segments = [];
            // 道路分段数量
            this.segmentCount = 500;
            // 道路分段间距
            this.segmentGap = 200;
            // 总长度
            this.trackDistance = this.segmentCount * this.segmentGap;
            // 每3条分段使用相同配色
            this.stripLength = 3;
            // 车道数量
            this.lanes = 3;
            // 道路颜色
            this.colors = {
                light : {road : '#6B6B6B', grass : '#10AA10', rumble : '#555555', lane : '#CCCCCC'},
                dark : {road : '#696969', grass : '#009A00', rumble : '#BBBBBB'}
            };

            // 初始化道路分段
            for(var i = 0; i < this.segmentCount; i++) {
                this.segments.push({
                    z : this.segmentGap * i,
                    color : Math.floor(i / this.stripLength) % 2 ? this.colors.dark : this.colors.light
                });
            }
        };

        Road.prototype = {
            findSegmentIndex : function(z) {
                return Math.floor(z / this.segmentGap) % this.segmentCount;
            },

            findSegment : function(z) {
                return this.segments[this.findSegmentIndex(z)];
            },

            rumbleWidth : function(projectedRoadWidth) {
                return projectedRoadWidth / Math.max(6,  2 * this.lanes); 
            },

            laneMarkerWidth: function(projectedRoadWidth) {
                return projectedRoadWidth / Math.max(32, 8 * this.lanes);
            }
        }

        function Racer(opts) {
            //水平视角
            this.fieldOfView = 100 * Math.PI / 180;
            //分辨率->坐标的比率
            this.depth = 1 / Math.tan(this.fieldOfView / 2);

            this.road = new Road();

            this.engine = new Phaser.Game(this.resolutionX, this.resolutionY, Phaser.AUTO, "racer");
            this.engine.state.add("racer", this, true);

            console.log(this.engine);
        }

        Racer.prototype = {
            resolutionX : 1024,

            resolutionY : 768,

            cameraX : 0,

            cameraY : 500,

            cameraZ : 0,

            preload : function() {
                this.engine.load.image("background-hills", "javascript-racer-master/images/background/hills.png");
                this.engine.load.image("background-sky", "javascript-racer-master/images/background/sky.png");
                this.engine.load.image("background-trees", "javascript-racer-master/images/background/trees.png");
                this.engine.load.image("player-left", "javascript-racer-master/images/sprites/player_left.png");
                this.engine.load.image("player-right", "javascript-racer-master/images/sprites/player_right.png");
                this.engine.load.image("player-straight", "javascript-racer-master/images/sprites/player_straight.png");
            },

            create : function() {
                this.backgroundBitmap = this.engine.add.bitmapData(this.resolutionX, this.resolutionY);
                this.engine.add.image(0, 0, this.backgroundBitmap);

                this.roadBitmap = this.engine.add.bitmapData(this.resolutionX, this.resolutionY);
                this.engine.add.image(0, 0, this.roadBitmap);

                // this.engine.add.image(this.resolutionX / 2 - 20, this.resolutionY - 50, "player-straight");

                var playerWidth = this.road.width * 0.3 * (this.depth / this.cameraY / this.depth) * this.resolutionX / 2 * 640 / 1024;
                var playerHeight = 41 / 80 * playerWidth;
                this.carBitmap = this.engine.add.bitmapData(playerWidth, playerHeight);
                this.engine.add.image(
                    (this.resolutionX - playerWidth) / 2,
                    this.resolutionY - playerHeight,
                    this.carBitmap
                );

                // 显示fps
                this.engine.time.advancedTiming = true;
                this.fpsText = this.engine.add.text(
                    20, 20, '', { font: '16px Arial', fill: '#ffffff' }
                );
            },

            update : function() {
                // 更新fps
                if (this.engine.time.fps !== 0) {
                    this.fpsText.setText(this.engine.time.fps + ' FPS');
                }

                this.cameraZ += speed;
                if(this.cameraZ > this.road.trackDistance) this.cameraZ -= this.road.trackDistance;

                if(this.engine.input.keyboard.isDown(Phaser.Keyboard.UP)) {
                    speed += accel;
                } else if(this.engine.input.keyboard.isDown(Phaser.Keyboard.DOWN)) {
                    speed += breaking;
                } else {
                    speed += decel;
                }
                if(speed > maxSpeed) speed = maxSpeed;
                if(speed < 0) speed = 0;

                if(this.engine.input.keyboard.isDown(Phaser.Keyboard.RIGHT)) {
                    this.cameraX += speed / maxSpeed * 20
                } else if(this.engine.input.keyboard.isDown(Phaser.Keyboard.LEFT)) {
                    this.cameraX += -speed / maxSpeed * 20
                }
                if(this.cameraX > 2000) this.cameraX = 2000;
                if(this.cameraX < -2000) this.cameraX = -2000;

                this.backgroundBitmap.ctx.drawImage(
                    this.engine.cache.getImage("background-sky"),
                    0, 0, 640, 480,
                    0, 0, this.resolutionX, this.resolutionY
                );

                this.backgroundBitmap.ctx.drawImage(
                    this.engine.cache.getImage("background-hills"),
                    0, 0, 640, 480,
                    0, 0, this.resolutionX, this.resolutionY
                );

                this.backgroundBitmap.ctx.drawImage(
                    this.engine.cache.getImage("background-trees"),
                    0, 0, 640, 480,
                    0, 0, this.resolutionX, this.resolutionY
                );

                this.carBitmap.ctx.drawImage(
                    this.engine.cache.getImage("player-straight"),
                    0, 0, 80, 41,
                    0, 0, this.carBitmap.width, this.carBitmap.height
                );

                var maxy = this.resolutionY;
                var ctx = this.roadBitmap.ctx;
                var index = this.road.findSegmentIndex(this.cameraZ);
                ctx.clearRect(0, 0, this.resolutionX, this.resolutionY);
                for(var n = 0; n < 500; n++) {
                    var cur = (index + n) % this.road.segmentCount,
                        segment = this.road.segments[cur];

                    // if(segment.z <= this.cameraZ) continue;

                    var p1 = this.project(-this.road.width / 2, 0, segment.z, this.cameraX, this.cameraY, cur < index ? this.cameraZ - this.road.trackDistance : this.cameraZ),
                        p2 = this.project(this.road.width / 2, 0, segment.z, this.cameraX, this.cameraY, cur < index ? this.cameraZ - this.road.trackDistance : this.cameraZ ),
                        p3 = this.project(this.road.width / 2, 0, segment.z + this.road.segmentGap, this.cameraX, this.cameraY, cur < index ? this.cameraZ - this.road.trackDistance : this.cameraZ),
                        p4 = this.project(-this.road.width / 2, 0, segment.z + this.road.segmentGap, this.cameraX, this.cameraY, cur < index ? this.cameraZ - this.road.trackDistance : this.cameraZ);

                    if(p3.screenY >= maxy) continue;

                    ctx.fillStyle = segment.color.grass;
                    ctx.fillRect(0, p4.screenY, this.resolutionX, p1.screenY - p4.screenY);

                    this.polygon(
                        ctx,
                        p1.screenX, p1.screenY,
                        p2.screenX, p2.screenY,
                        p3.screenX, p3.screenY,
                        p4.screenX, p4.screenY,
                        segment.color.road
                    );

                    var w1 = p2.screenX - p1.screenX,
                        w2 = p3.screenX - p4.screenX,
                        rw1 = this.road.rumbleWidth(w1),
                        rw2 = this.road.rumbleWidth(w2),
                        lw1 = this.road.laneMarkerWidth(w1),
                        lw2 = this.road.laneMarkerWidth(w2);

                    this.polygon(
                        ctx,
                        p1.screenX - rw1, p1.screenY,
                        p1.screenX, p1.screenY,
                        p4.screenX, p4.screenY,
                        p4.screenX - rw2, p4.screenY,
                        segment.color.rumble
                    );

                    this.polygon(
                        ctx,
                        p2.screenX + rw1, p2.screenY,
                        p2.screenX, p2.screenY,
                        p3.screenX, p3.screenY,
                        p3.screenX + rw2, p3.screenY,
                        segment.color.rumble
                    );

                    if(segment.color.lane) {
                        for(var i = 1; i < this.road.lanes; i++) {
                            this.polygon(
                                ctx,
                                p1.screenX + w1 / this.road.lanes * i - lw1 / 2, p1.screenY,
                                p1.screenX + w1 / this.road.lanes * i + lw1 / 2, p1.screenY,
                                p4.screenX + w2 / this.road.lanes * i + lw2 / 2, p4.screenY,
                                p4.screenX + w2 / this.road.lanes * i - lw2 / 2, p4.screenY,
                                segment.color.lane
                            );
                        }
                    }

                    maxy = p3.screenY;
                }

                this.roadBitmap.dirty = true;
            },

            project : function(x, y, z, cameraX, cameraY, cameraZ) {
                var scale = this.depth / (z - cameraZ);
                return {
                    screenX : Math.round(this.resolutionX / 2 + this.resolutionX / 2 * scale * (x - cameraX)),
                    screenY : Math.round(this.resolutionY / 2 - this.resolutionY / 2 * scale * (y - cameraY))
                }
            },

            polygon : function(ctx, x1, y1, x2, y2, x3, y3, x4, y4, color) {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.lineTo(x3, y3);
                ctx.lineTo(x4, y4);
                ctx.closePath();
                ctx.fill();
            }
        };

        var racer = new Racer();
    </script>
</body>
</html>